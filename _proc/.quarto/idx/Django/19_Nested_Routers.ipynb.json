{"title":"Nested Routers","markdown":{"yaml":{"description":"Nested Routers","output-file":"nested_routers.html","skip_exec":true,"skip_showdoc":true,"title":"Nested Routers"},"headingText":"1. Introduction to Routers in DRF","containsRefs":false,"markdown":"\n\n\n\n<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->\n\n\n**Routers** in Django REST Framework are classes that automatically generate URL configurations for your API views. They simplify the process of mapping HTTP methods to view actions, reducing boilerplate code and ensuring consistency across your API.\n\n### **Key Components:**\n\n- **ViewSets**: Classes that combine the logic for multiple related views (e.g., list, create, retrieve, update, delete).\n- **Router Classes**: Handle the URL routing by registering ViewSets and generating the appropriate URL patterns.\n\n### **Basic Router Example:**\n\n```python\n# urls.py\nfrom django.urls import path, include\nfrom rest_framework.routers import DefaultRouter\nfrom .views import AuthorViewSet, BookViewSet\n\nrouter = DefaultRouter()\nrouter.register(r'authors', AuthorViewSet)\nrouter.register(r'books', BookViewSet)\n\nurlpatterns = [\n    path('', include(router.urls)),\n]\n```\n\nThis setup automatically creates routes like:\n\n- `/authors/` (GET, POST)\n- `/authors/{id}/` (GET, PUT, DELETE)\n- `/books/` (GET, POST)\n- `/books/{id}/` (GET, PUT, DELETE)\n\n## 2. What Are Nested Routers?\n\n**Nested Routers** extend the functionality of standard routers by allowing you to create nested URL patterns that reflect the relationships between different resources (models) in your application. This is particularly useful when you have related models, such as a `Client` having multiple `Treatments`.\n\n### **Benefits of Nested Routers:**\n\n- **Hierarchical URL Structure**: Reflects the relationships between resources, making the API more intuitive.\n- **Scoped Access**: Ensures that nested resources are accessed within the context of their parent resource.\n- **Organized Codebase**: Keeps URL configurations clean and manageable, especially in large projects.\n\n### **Example of Nested Routes:**\n\nGiven models `Client` and `Treatment`, where a `Client` has many `Treatments`:\n\n- `/clients/` (List/Create Clients)\n- `/clients/{client_id}/` (Retrieve/Update/Delete a Client)\n- `/clients/{client_id}/treatments/` (List/Create Treatments for a Client)\n- `/clients/{client_id}/treatments/{treatment_id}/` (Retrieve/Update/Delete a Treatment for a Client)\n\n## 3. When to Use Nested Routers\n\n**Use Nested Routers When:**\n\n- **Hierarchical Relationships**: Models have parent-child relationships (e.g., Authors and Books, Users and Posts).\n- **Scoped Operations**: Operations on child resources should be scoped to a specific parent (e.g., adding a comment to a specific post).\n- **Improved Readability**: You want your API endpoints to clearly represent the relationships between resources.\n\n**Avoid Nested Routers When:**\n\n- **Deep Nesting**: Excessive nesting can lead to complex and unwieldy URLs. Limit nesting to 1-2 levels.\n- **No Clear Hierarchy**: Models are not directly related or the relationship does not require nested access.\n- **Alternative Structures Suffice**: Flat structures with query parameters or filters can achieve similar results without nesting.\n\n---\n\n## 4. Installing and Setting Up Nested Routers\n\nTo implement nested routers in DRF, you typically use the [`drf-nested-routers`](https://github.com/alanjds/drf-nested-routers) package, which extends DRF’s router classes to support nested URL patterns.\n\n### **Installation:**\n\nUse `pip` to install `drf-nested-routers`:\n\n```bash\npip install drf-nested-routers\n```\n\n### **Verify Installation:**\n\nEnsure that `drf-nested-routers` is installed correctly by checking the package list:\n\n```bash\npip list | grep drf-nested-routers\n```\n\n## 5. Basic Implementation with `drf-nested-routers`\n\nLet’s walk through a basic implementation of nested routers using `drf-nested-routers`.\n\n### **Scenario:**\n\nYou have two models: `Author` and `Book`. Each `Author` can have multiple `Books`.\n\n### **Models:**\n\n```python\n# models.py\nfrom django.db import models\n\nclass Author(models.Model):\n    name = models.CharField(max_length=100)\n    bio = models.TextField(blank=True)\n\n    def __str__(self):\n        return self.name\n\nclass Book(models.Model):\n    author = models.ForeignKey(Author, related_name='books', on_delete=models.CASCADE)\n    title = models.CharField(max_length=200)\n    published_date = models.DateField()\n\n    def __str__(self):\n        return self.title\n```\n\n### **Serializers:**\n\n```python\n# serializers.py\nfrom rest_framework import serializers\nfrom .models import Author, Book\n\nclass BookSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Book\n        fields = ['id', 'title', 'published_date', 'author']\n\nclass AuthorSerializer(serializers.ModelSerializer):\n    books = BookSerializer(many=True, read_only=True)  # Nested representation\n\n    class Meta:\n        model = Author\n        fields = ['id', 'name', 'bio', 'books']\n```\n\n### **ViewSets:**\n\n```python\n# views.py\nfrom rest_framework import viewsets\nfrom .models import Author, Book\nfrom .serializers import AuthorSerializer, BookSerializer\n\nclass AuthorViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    A viewset for viewing and editing author instances.\n    \"\"\"\n    queryset = Author.objects.all()\n    serializer_class = AuthorSerializer\n\nclass BookViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    A viewset for viewing and editing book instances.\n    \"\"\"\n    serializer_class = BookSerializer\n\n    def get_queryset(self):\n        \"\"\"\n        Optionally restricts the returned books to a given author,\n        by filtering against a `author_pk` query parameter in the URL.\n        \"\"\"\n        queryset = Book.objects.all()\n        author_pk = self.kwargs.get('author_pk')\n        if author_pk is not None:\n            queryset = queryset.filter(author_id=author_pk)\n        return queryset\n\n    def perform_create(self, serializer):\n        \"\"\"\n        Associates the book with the given author.\n        \"\"\"\n        author_pk = self.kwargs.get('author_pk')\n        serializer.save(author_id=author_pk)\n```\n\n### **URL Configuration with Nested Routers:**\n\n```python\n# urls.py\nfrom django.urls import path, include\nfrom rest_framework_nested import routers\nfrom .views import AuthorViewSet, BookViewSet\n\n# Create the main router and register the AuthorViewSet\nrouter = routers.DefaultRouter()\nrouter.register(r'authors', AuthorViewSet, basename='authors')\n\n# Create a nested router for books under authors\nauthors_router = routers.NestedDefaultRouter(router, r'authors', lookup='author')\nauthors_router.register(r'books', BookViewSet, basename='author-books')\n\n# Include both routers in the URL patterns\nurlpatterns = [\n    path('', include(router.urls)),\n    path('', include(authors_router.urls)),\n]\n```\n\n### **Generated URL Patterns:**\n\n- `/authors/` - List/Create Authors\n- `/authors/{author_id}/` - Retrieve/Update/Delete a Specific Author\n- `/authors/{author_id}/books/` - List/Create Books for a Specific Author\n- `/authors/{author_id}/books/{book_id}/` - Retrieve/Update/Delete a Specific Book for an Author\n\n### **Testing the Endpoints:**\n\nUsing tools like **Postman** or **cURL**, you can interact with the API:\n\n- **List Authors:**\n\n  ```http\n  GET /authors/\n  ```\n\n- **Retrieve a Specific Author:**\n\n  ```http\n  GET /authors/1/\n  ```\n\n- **List Books for an Author:**\n\n  ```http\n  GET /authors/1/books/\n  ```\n\n- **Create a Book for an Author:**\n\n  ```http\n  POST /authors/1/books/\n  Content-Type: application/json\n\n  {\n      \"title\": \"New Book Title\",\n      \"published_date\": \"2024-01-01\"\n  }\n  ```\n\n- **Retrieve a Specific Book for an Author:**\n\n  ```http\n  GET /authors/1/books/2/\n  ```\n\n## 6. Advanced Usage and Customization\n\nWhile basic nested routing is straightforward, you might encounter scenarios that require more advanced configurations.\n\n### **a. Multiple Levels of Nesting**\n\nYou can nest routers to multiple levels, but it's generally recommended to keep nesting to a reasonable depth (typically 2 levels) to avoid overly complex URLs.\n\n**Example:**\n\nModels: `Author`, `Book`, `Chapter`\n\n```python\n# urls.py\nfrom rest_framework_nested import routers\nfrom .views import AuthorViewSet, BookViewSet, ChapterViewSet\n\nrouter = routers.DefaultRouter()\nrouter.register(r'authors', AuthorViewSet, basename='authors')\n\nauthors_router = routers.NestedDefaultRouter(router, r'authors', lookup='author')\nauthors_router.register(r'books', BookViewSet, basename='author-books')\n\nbooks_router = routers.NestedDefaultRouter(authors_router, r'books', lookup='book')\nbooks_router.register(r'chapters', ChapterViewSet, basename='book-chapters')\n\nurlpatterns = [\n    path('', include(router.urls)),\n    path('', include(authors_router.urls)),\n    path('', include(books_router.urls)),\n]\n```\n\nGenerated URLs:\n\n- `/authors/{author_id}/books/{book_id}/chapters/` - List/Create Chapters for a Book\n- `/authors/{author_id}/books/{book_id}/chapters/{chapter_id}/` - Retrieve/Update/Delete a Specific Chapter\n\n### **b. Using `trailing_slash=False`**\n\nBy default, DRF routers append a trailing slash to URLs. If you prefer URLs without a trailing slash, you can configure it globally or per router.\n\n**Example:**\n\n```python\nrouter = routers.DefaultRouter(trailing_slash=False)\nrouter.register(r'authors', AuthorViewSet, basename='authors')\n\nauthors_router = routers.NestedDefaultRouter(router, r'authors', lookup='author', trailing_slash=False)\nauthors_router.register(r'books', BookViewSet, basename='author-books')\n```\n\n### **c. Custom Lookup Fields**\n\nBy default, DRF uses the `pk` (primary key) for URL lookups. You can customize this to use other fields, such as `slug`.\n\n**Example:**\n\n```python\n# views.py\nclass AuthorViewSet(viewsets.ModelViewSet):\n    queryset = Author.objects.all()\n    serializer_class = AuthorSerializer\n    lookup_field = 'slug'\n\n# urls.py\nrouter.register(r'authors', AuthorViewSet, basename='authors')\nauthors_router = routers.NestedDefaultRouter(router, r'authors', lookup='author', lookup_field='slug')\n```\n\n### **d. Handling Permissions and Access Control**\n\nNested routers don't inherently handle permissions differently. However, you can leverage the nested context in your ViewSets to enforce permissions based on the parent resource.\n\n**Example:**\n\n```python\n# views.py\nfrom rest_framework import permissions\n\nclass BookViewSet(viewsets.ModelViewSet):\n    serializer_class = BookSerializer\n    permission_classes = [permissions.IsAuthenticated]\n\n    def get_queryset(self):\n        author_pk = self.kwargs.get('author_pk')\n        return Book.objects.filter(author_id=author_pk)\n\n    def perform_create(self, serializer):\n        author_pk = self.kwargs.get('author_pk')\n        author = get_object_or_404(Author, pk=author_pk)\n        serializer.save(author=author)\n```\n\n### **e. Custom Actions in Nested ViewSets**\n\nYou can define custom actions (e.g., additional endpoints) within nested ViewSets to handle specific operations.\n\n**Example: Adding a custom action to retrieve books published after a certain date:**\n\n```python\n# views.py\nfrom rest_framework.decorators import action\nfrom rest_framework.response import Response\nfrom django.utils.dateparse import parse_date\n\nclass BookViewSet(viewsets.ModelViewSet):\n    # ... existing methods ...\n\n    @action(detail=False, methods=['get'])\n    def published_after(self, request, author_pk=None):\n        date_str = request.query_params.get('date')\n        if not date_str:\n            return Response({\"error\": \"Date parameter is required.\"}, status=400)\n        date = parse_date(date_str)\n        if not date:\n            return Response({\"error\": \"Invalid date format.\"}, status=400)\n        books = self.get_queryset().filter(published_date__gt=date)\n        serializer = self.get_serializer(books, many=True)\n        return Response(serializer.data)\n```\n\n**Accessing the Custom Action:**\n\n```\nGET /authors/{author_id}/books/published_after/?date=2024-01-01\n```\n\n## 7. Common Use Cases and Examples\n\n### **a. E-commerce Application**\n\n**Models:**\n\n- `Category`\n- `Product`\n- `Review`\n\n**URL Structure:**\n\n- `/categories/`\n- `/categories/{category_id}/products/`\n- `/categories/{category_id}/products/{product_id}/reviews/`\n\n**Implementation:**\n\n```python\n# urls.py\nrouter = routers.DefaultRouter()\nrouter.register(r'categories', CategoryViewSet, basename='categories')\n\ncategories_router = routers.NestedDefaultRouter(router, r'categories', lookup='category')\ncategories_router.register(r'products', ProductViewSet, basename='category-products')\n\nproducts_router = routers.NestedDefaultRouter(categories_router, r'products', lookup='product')\nproducts_router.register(r'reviews', ReviewViewSet, basename='product-reviews')\n\nurlpatterns = [\n    path('', include(router.urls)),\n    path('', include(categories_router.urls)),\n    path('', include(products_router.urls)),\n]\n```\n\n### **b. Blogging Platform**\n\n**Models:**\n\n- `Author`\n- `Post`\n- `Comment`\n\n**URL Structure:**\n\n- `/authors/`\n- `/authors/{author_id}/posts/`\n- `/authors/{author_id}/posts/{post_id}/comments/`\n\n**Implementation:**\n\n```python\n# urls.py\nrouter = routers.DefaultRouter()\nrouter.register(r'authors', AuthorViewSet, basename='authors')\n\nauthors_router = routers.NestedDefaultRouter(router, r'authors', lookup='author')\nauthors_router.register(r'posts', PostViewSet, basename='author-posts')\n\nposts_router = routers.NestedDefaultRouter(authors_router, r'posts', lookup='post')\nposts_router.register(r'comments', CommentViewSet, basename='post-comments')\n\nurlpatterns = [\n    path('', include(router.urls)),\n    path('', include(authors_router.urls)),\n    path('', include(posts_router.urls)),\n]\n```\n\n## 8. Potential Pitfalls and How to Avoid Them\n\nWhile nested routers are powerful, they can introduce complexity if not used judiciously. Here are common pitfalls and strategies to avoid them:\n\n### **a. Over-Nesting**\n\n**Issue:**\nExcessive nesting leads to deeply hierarchical URLs, making them hard to manage and understand.\n\n**Solution:**\nLimit nesting to 1-2 levels. For deeper relationships, consider alternative approaches like query parameters or flattening the URL structure.\n\n### **b. Complex URL Patterns**\n\n**Issue:**\nManaging multiple nested routers can result in complex URL configurations.\n\n**Solution:**\nOrganize your `urls.py` logically, possibly splitting into multiple modules if necessary. Use consistent naming conventions and documentation.\n\n### **c. Handling Lookup Fields**\n\n**Issue:**\nIncorrect or inconsistent lookup fields can lead to broken URLs and failed lookups.\n\n**Solution:**\nEnsure that `lookup_field` is consistently defined across ViewSets and routers. Use meaningful and unique fields like `slug` if necessary.\n\n### **d. Performance Concerns**\n\n**Issue:**\nNested queries can lead to increased database hits, affecting performance.\n\n**Solution:**\nOptimize your ViewSets by using `select_related` and `prefetch_related` to minimize database queries. Implement pagination where appropriate.\n\n### **e. Permissions and Access Control**\n\n**Issue:**\nInconsistent permissions across nested resources can lead to security vulnerabilities.\n\n**Solution:**\nDefine and enforce permissions within each ViewSet, considering the context provided by nested relationships. Use DRF's permission classes effectively.\n\n### **f. Cache Invalidation**\n\n**Issue:**\nWhen using caching mechanisms, nested resources might require careful cache invalidation strategies.\n\n**Solution:**\nImplement cache invalidation rules that account for changes in parent resources affecting child resources.\n\n## 9. Best Practices\n\nAdhering to best practices ensures that your use of nested routers is effective and maintainable.\n\n### **a. Keep Nesting Shallow**\n\nLimit nesting to avoid overly complex URLs. A common guideline is to nest no more than 1-2 levels deep.\n\n### **b. Use Meaningful Lookup Fields**\n\nPrefer using unique and meaningful fields like `slug` over numeric IDs when appropriate, enhancing the readability of URLs.\n\n### **c. Optimize Querysets**\n\nLeverage Django's ORM capabilities (`select_related`, `prefetch_related`) to optimize database access and reduce query counts.\n\n### **d. Consistent Naming Conventions**\n\nUse consistent naming for routers, ViewSets, and URL patterns to improve code readability and maintainability.\n\n### **e. Implement Proper Permissions**\n\nEnsure that each ViewSet has appropriate permission classes to secure access to resources, especially in nested contexts.\n\n### **f. Document Your API**\n\nUse tools like **Swagger** or **DRF-YASG** to generate API documentation, making it easier for developers to understand and use your nested endpoints.\n\n### **g. Handle Errors Gracefully**\n\nImplement robust error handling in your ViewSets to manage scenarios where parent resources do not exist or access is unauthorized.\n\n### **h. Consider Alternative Approaches When Necessary**\n\nIf nesting becomes too complex, explore alternative structures such as:\n\n- **Query Parameters**: Filter resources based on query parameters without nesting.\n- **Separate Endpoints**: Provide separate endpoints for related resources without hierarchical URLs.\n\n## 10. Alternatives to Nested Routers\n\nWhile nested routers are useful, they aren't always the best solution. Here are some alternatives:\n\n### **a. Flat Routers with Query Parameters**\n\nInstead of nesting, use flat URLs and filter child resources based on query parameters.\n\n**Example:**\n\n- `/books/?author_id=1/`\n\n**Pros:**\n\n- Simpler URL structure.\n- Easier to manage and understand.\n\n**Cons:**\n\n- Less intuitive in reflecting relationships.\n- May require more complex filtering logic.\n\n### **b. Hyperlinked Relationships**\n\nUse hyperlinked serializers to include links to related resources without nesting URLs.\n\n**Pros:**\n\n- Decouples URL structure from resource relationships.\n- Flexible and RESTful.\n\n**Cons:**\n\n- Less intuitive browsing through related resources via URL.\n\n### **c. Custom URL Patterns**\n\nDefine custom URL patterns tailored to specific needs rather than relying solely on nested routers.\n\n**Pros:**\n\n- Greater control over URL structure.\n- Can cater to complex or unique routing requirements.\n\n**Cons:**\n\n- More manual configuration.\n- Potential for inconsistency.\n\n### **d. Use DRF's `ViewSet` Without Routers**\n\nManually map URLs to ViewSet actions without using routers.\n\n**Pros:**\n\n- Full control over URL patterns.\n- Avoids potential complexities of nested routers.\n\n**Cons:**\n\n- Increased boilerplate code.\n- Potentially less scalable for large APIs.\n","srcMarkdownNoYaml":"\n\n\n\n<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->\n\n## 1. Introduction to Routers in DRF\n\n**Routers** in Django REST Framework are classes that automatically generate URL configurations for your API views. They simplify the process of mapping HTTP methods to view actions, reducing boilerplate code and ensuring consistency across your API.\n\n### **Key Components:**\n\n- **ViewSets**: Classes that combine the logic for multiple related views (e.g., list, create, retrieve, update, delete).\n- **Router Classes**: Handle the URL routing by registering ViewSets and generating the appropriate URL patterns.\n\n### **Basic Router Example:**\n\n```python\n# urls.py\nfrom django.urls import path, include\nfrom rest_framework.routers import DefaultRouter\nfrom .views import AuthorViewSet, BookViewSet\n\nrouter = DefaultRouter()\nrouter.register(r'authors', AuthorViewSet)\nrouter.register(r'books', BookViewSet)\n\nurlpatterns = [\n    path('', include(router.urls)),\n]\n```\n\nThis setup automatically creates routes like:\n\n- `/authors/` (GET, POST)\n- `/authors/{id}/` (GET, PUT, DELETE)\n- `/books/` (GET, POST)\n- `/books/{id}/` (GET, PUT, DELETE)\n\n## 2. What Are Nested Routers?\n\n**Nested Routers** extend the functionality of standard routers by allowing you to create nested URL patterns that reflect the relationships between different resources (models) in your application. This is particularly useful when you have related models, such as a `Client` having multiple `Treatments`.\n\n### **Benefits of Nested Routers:**\n\n- **Hierarchical URL Structure**: Reflects the relationships between resources, making the API more intuitive.\n- **Scoped Access**: Ensures that nested resources are accessed within the context of their parent resource.\n- **Organized Codebase**: Keeps URL configurations clean and manageable, especially in large projects.\n\n### **Example of Nested Routes:**\n\nGiven models `Client` and `Treatment`, where a `Client` has many `Treatments`:\n\n- `/clients/` (List/Create Clients)\n- `/clients/{client_id}/` (Retrieve/Update/Delete a Client)\n- `/clients/{client_id}/treatments/` (List/Create Treatments for a Client)\n- `/clients/{client_id}/treatments/{treatment_id}/` (Retrieve/Update/Delete a Treatment for a Client)\n\n## 3. When to Use Nested Routers\n\n**Use Nested Routers When:**\n\n- **Hierarchical Relationships**: Models have parent-child relationships (e.g., Authors and Books, Users and Posts).\n- **Scoped Operations**: Operations on child resources should be scoped to a specific parent (e.g., adding a comment to a specific post).\n- **Improved Readability**: You want your API endpoints to clearly represent the relationships between resources.\n\n**Avoid Nested Routers When:**\n\n- **Deep Nesting**: Excessive nesting can lead to complex and unwieldy URLs. Limit nesting to 1-2 levels.\n- **No Clear Hierarchy**: Models are not directly related or the relationship does not require nested access.\n- **Alternative Structures Suffice**: Flat structures with query parameters or filters can achieve similar results without nesting.\n\n---\n\n## 4. Installing and Setting Up Nested Routers\n\nTo implement nested routers in DRF, you typically use the [`drf-nested-routers`](https://github.com/alanjds/drf-nested-routers) package, which extends DRF’s router classes to support nested URL patterns.\n\n### **Installation:**\n\nUse `pip` to install `drf-nested-routers`:\n\n```bash\npip install drf-nested-routers\n```\n\n### **Verify Installation:**\n\nEnsure that `drf-nested-routers` is installed correctly by checking the package list:\n\n```bash\npip list | grep drf-nested-routers\n```\n\n## 5. Basic Implementation with `drf-nested-routers`\n\nLet’s walk through a basic implementation of nested routers using `drf-nested-routers`.\n\n### **Scenario:**\n\nYou have two models: `Author` and `Book`. Each `Author` can have multiple `Books`.\n\n### **Models:**\n\n```python\n# models.py\nfrom django.db import models\n\nclass Author(models.Model):\n    name = models.CharField(max_length=100)\n    bio = models.TextField(blank=True)\n\n    def __str__(self):\n        return self.name\n\nclass Book(models.Model):\n    author = models.ForeignKey(Author, related_name='books', on_delete=models.CASCADE)\n    title = models.CharField(max_length=200)\n    published_date = models.DateField()\n\n    def __str__(self):\n        return self.title\n```\n\n### **Serializers:**\n\n```python\n# serializers.py\nfrom rest_framework import serializers\nfrom .models import Author, Book\n\nclass BookSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Book\n        fields = ['id', 'title', 'published_date', 'author']\n\nclass AuthorSerializer(serializers.ModelSerializer):\n    books = BookSerializer(many=True, read_only=True)  # Nested representation\n\n    class Meta:\n        model = Author\n        fields = ['id', 'name', 'bio', 'books']\n```\n\n### **ViewSets:**\n\n```python\n# views.py\nfrom rest_framework import viewsets\nfrom .models import Author, Book\nfrom .serializers import AuthorSerializer, BookSerializer\n\nclass AuthorViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    A viewset for viewing and editing author instances.\n    \"\"\"\n    queryset = Author.objects.all()\n    serializer_class = AuthorSerializer\n\nclass BookViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    A viewset for viewing and editing book instances.\n    \"\"\"\n    serializer_class = BookSerializer\n\n    def get_queryset(self):\n        \"\"\"\n        Optionally restricts the returned books to a given author,\n        by filtering against a `author_pk` query parameter in the URL.\n        \"\"\"\n        queryset = Book.objects.all()\n        author_pk = self.kwargs.get('author_pk')\n        if author_pk is not None:\n            queryset = queryset.filter(author_id=author_pk)\n        return queryset\n\n    def perform_create(self, serializer):\n        \"\"\"\n        Associates the book with the given author.\n        \"\"\"\n        author_pk = self.kwargs.get('author_pk')\n        serializer.save(author_id=author_pk)\n```\n\n### **URL Configuration with Nested Routers:**\n\n```python\n# urls.py\nfrom django.urls import path, include\nfrom rest_framework_nested import routers\nfrom .views import AuthorViewSet, BookViewSet\n\n# Create the main router and register the AuthorViewSet\nrouter = routers.DefaultRouter()\nrouter.register(r'authors', AuthorViewSet, basename='authors')\n\n# Create a nested router for books under authors\nauthors_router = routers.NestedDefaultRouter(router, r'authors', lookup='author')\nauthors_router.register(r'books', BookViewSet, basename='author-books')\n\n# Include both routers in the URL patterns\nurlpatterns = [\n    path('', include(router.urls)),\n    path('', include(authors_router.urls)),\n]\n```\n\n### **Generated URL Patterns:**\n\n- `/authors/` - List/Create Authors\n- `/authors/{author_id}/` - Retrieve/Update/Delete a Specific Author\n- `/authors/{author_id}/books/` - List/Create Books for a Specific Author\n- `/authors/{author_id}/books/{book_id}/` - Retrieve/Update/Delete a Specific Book for an Author\n\n### **Testing the Endpoints:**\n\nUsing tools like **Postman** or **cURL**, you can interact with the API:\n\n- **List Authors:**\n\n  ```http\n  GET /authors/\n  ```\n\n- **Retrieve a Specific Author:**\n\n  ```http\n  GET /authors/1/\n  ```\n\n- **List Books for an Author:**\n\n  ```http\n  GET /authors/1/books/\n  ```\n\n- **Create a Book for an Author:**\n\n  ```http\n  POST /authors/1/books/\n  Content-Type: application/json\n\n  {\n      \"title\": \"New Book Title\",\n      \"published_date\": \"2024-01-01\"\n  }\n  ```\n\n- **Retrieve a Specific Book for an Author:**\n\n  ```http\n  GET /authors/1/books/2/\n  ```\n\n## 6. Advanced Usage and Customization\n\nWhile basic nested routing is straightforward, you might encounter scenarios that require more advanced configurations.\n\n### **a. Multiple Levels of Nesting**\n\nYou can nest routers to multiple levels, but it's generally recommended to keep nesting to a reasonable depth (typically 2 levels) to avoid overly complex URLs.\n\n**Example:**\n\nModels: `Author`, `Book`, `Chapter`\n\n```python\n# urls.py\nfrom rest_framework_nested import routers\nfrom .views import AuthorViewSet, BookViewSet, ChapterViewSet\n\nrouter = routers.DefaultRouter()\nrouter.register(r'authors', AuthorViewSet, basename='authors')\n\nauthors_router = routers.NestedDefaultRouter(router, r'authors', lookup='author')\nauthors_router.register(r'books', BookViewSet, basename='author-books')\n\nbooks_router = routers.NestedDefaultRouter(authors_router, r'books', lookup='book')\nbooks_router.register(r'chapters', ChapterViewSet, basename='book-chapters')\n\nurlpatterns = [\n    path('', include(router.urls)),\n    path('', include(authors_router.urls)),\n    path('', include(books_router.urls)),\n]\n```\n\nGenerated URLs:\n\n- `/authors/{author_id}/books/{book_id}/chapters/` - List/Create Chapters for a Book\n- `/authors/{author_id}/books/{book_id}/chapters/{chapter_id}/` - Retrieve/Update/Delete a Specific Chapter\n\n### **b. Using `trailing_slash=False`**\n\nBy default, DRF routers append a trailing slash to URLs. If you prefer URLs without a trailing slash, you can configure it globally or per router.\n\n**Example:**\n\n```python\nrouter = routers.DefaultRouter(trailing_slash=False)\nrouter.register(r'authors', AuthorViewSet, basename='authors')\n\nauthors_router = routers.NestedDefaultRouter(router, r'authors', lookup='author', trailing_slash=False)\nauthors_router.register(r'books', BookViewSet, basename='author-books')\n```\n\n### **c. Custom Lookup Fields**\n\nBy default, DRF uses the `pk` (primary key) for URL lookups. You can customize this to use other fields, such as `slug`.\n\n**Example:**\n\n```python\n# views.py\nclass AuthorViewSet(viewsets.ModelViewSet):\n    queryset = Author.objects.all()\n    serializer_class = AuthorSerializer\n    lookup_field = 'slug'\n\n# urls.py\nrouter.register(r'authors', AuthorViewSet, basename='authors')\nauthors_router = routers.NestedDefaultRouter(router, r'authors', lookup='author', lookup_field='slug')\n```\n\n### **d. Handling Permissions and Access Control**\n\nNested routers don't inherently handle permissions differently. However, you can leverage the nested context in your ViewSets to enforce permissions based on the parent resource.\n\n**Example:**\n\n```python\n# views.py\nfrom rest_framework import permissions\n\nclass BookViewSet(viewsets.ModelViewSet):\n    serializer_class = BookSerializer\n    permission_classes = [permissions.IsAuthenticated]\n\n    def get_queryset(self):\n        author_pk = self.kwargs.get('author_pk')\n        return Book.objects.filter(author_id=author_pk)\n\n    def perform_create(self, serializer):\n        author_pk = self.kwargs.get('author_pk')\n        author = get_object_or_404(Author, pk=author_pk)\n        serializer.save(author=author)\n```\n\n### **e. Custom Actions in Nested ViewSets**\n\nYou can define custom actions (e.g., additional endpoints) within nested ViewSets to handle specific operations.\n\n**Example: Adding a custom action to retrieve books published after a certain date:**\n\n```python\n# views.py\nfrom rest_framework.decorators import action\nfrom rest_framework.response import Response\nfrom django.utils.dateparse import parse_date\n\nclass BookViewSet(viewsets.ModelViewSet):\n    # ... existing methods ...\n\n    @action(detail=False, methods=['get'])\n    def published_after(self, request, author_pk=None):\n        date_str = request.query_params.get('date')\n        if not date_str:\n            return Response({\"error\": \"Date parameter is required.\"}, status=400)\n        date = parse_date(date_str)\n        if not date:\n            return Response({\"error\": \"Invalid date format.\"}, status=400)\n        books = self.get_queryset().filter(published_date__gt=date)\n        serializer = self.get_serializer(books, many=True)\n        return Response(serializer.data)\n```\n\n**Accessing the Custom Action:**\n\n```\nGET /authors/{author_id}/books/published_after/?date=2024-01-01\n```\n\n## 7. Common Use Cases and Examples\n\n### **a. E-commerce Application**\n\n**Models:**\n\n- `Category`\n- `Product`\n- `Review`\n\n**URL Structure:**\n\n- `/categories/`\n- `/categories/{category_id}/products/`\n- `/categories/{category_id}/products/{product_id}/reviews/`\n\n**Implementation:**\n\n```python\n# urls.py\nrouter = routers.DefaultRouter()\nrouter.register(r'categories', CategoryViewSet, basename='categories')\n\ncategories_router = routers.NestedDefaultRouter(router, r'categories', lookup='category')\ncategories_router.register(r'products', ProductViewSet, basename='category-products')\n\nproducts_router = routers.NestedDefaultRouter(categories_router, r'products', lookup='product')\nproducts_router.register(r'reviews', ReviewViewSet, basename='product-reviews')\n\nurlpatterns = [\n    path('', include(router.urls)),\n    path('', include(categories_router.urls)),\n    path('', include(products_router.urls)),\n]\n```\n\n### **b. Blogging Platform**\n\n**Models:**\n\n- `Author`\n- `Post`\n- `Comment`\n\n**URL Structure:**\n\n- `/authors/`\n- `/authors/{author_id}/posts/`\n- `/authors/{author_id}/posts/{post_id}/comments/`\n\n**Implementation:**\n\n```python\n# urls.py\nrouter = routers.DefaultRouter()\nrouter.register(r'authors', AuthorViewSet, basename='authors')\n\nauthors_router = routers.NestedDefaultRouter(router, r'authors', lookup='author')\nauthors_router.register(r'posts', PostViewSet, basename='author-posts')\n\nposts_router = routers.NestedDefaultRouter(authors_router, r'posts', lookup='post')\nposts_router.register(r'comments', CommentViewSet, basename='post-comments')\n\nurlpatterns = [\n    path('', include(router.urls)),\n    path('', include(authors_router.urls)),\n    path('', include(posts_router.urls)),\n]\n```\n\n## 8. Potential Pitfalls and How to Avoid Them\n\nWhile nested routers are powerful, they can introduce complexity if not used judiciously. Here are common pitfalls and strategies to avoid them:\n\n### **a. Over-Nesting**\n\n**Issue:**\nExcessive nesting leads to deeply hierarchical URLs, making them hard to manage and understand.\n\n**Solution:**\nLimit nesting to 1-2 levels. For deeper relationships, consider alternative approaches like query parameters or flattening the URL structure.\n\n### **b. Complex URL Patterns**\n\n**Issue:**\nManaging multiple nested routers can result in complex URL configurations.\n\n**Solution:**\nOrganize your `urls.py` logically, possibly splitting into multiple modules if necessary. Use consistent naming conventions and documentation.\n\n### **c. Handling Lookup Fields**\n\n**Issue:**\nIncorrect or inconsistent lookup fields can lead to broken URLs and failed lookups.\n\n**Solution:**\nEnsure that `lookup_field` is consistently defined across ViewSets and routers. Use meaningful and unique fields like `slug` if necessary.\n\n### **d. Performance Concerns**\n\n**Issue:**\nNested queries can lead to increased database hits, affecting performance.\n\n**Solution:**\nOptimize your ViewSets by using `select_related` and `prefetch_related` to minimize database queries. Implement pagination where appropriate.\n\n### **e. Permissions and Access Control**\n\n**Issue:**\nInconsistent permissions across nested resources can lead to security vulnerabilities.\n\n**Solution:**\nDefine and enforce permissions within each ViewSet, considering the context provided by nested relationships. Use DRF's permission classes effectively.\n\n### **f. Cache Invalidation**\n\n**Issue:**\nWhen using caching mechanisms, nested resources might require careful cache invalidation strategies.\n\n**Solution:**\nImplement cache invalidation rules that account for changes in parent resources affecting child resources.\n\n## 9. Best Practices\n\nAdhering to best practices ensures that your use of nested routers is effective and maintainable.\n\n### **a. Keep Nesting Shallow**\n\nLimit nesting to avoid overly complex URLs. A common guideline is to nest no more than 1-2 levels deep.\n\n### **b. Use Meaningful Lookup Fields**\n\nPrefer using unique and meaningful fields like `slug` over numeric IDs when appropriate, enhancing the readability of URLs.\n\n### **c. Optimize Querysets**\n\nLeverage Django's ORM capabilities (`select_related`, `prefetch_related`) to optimize database access and reduce query counts.\n\n### **d. Consistent Naming Conventions**\n\nUse consistent naming for routers, ViewSets, and URL patterns to improve code readability and maintainability.\n\n### **e. Implement Proper Permissions**\n\nEnsure that each ViewSet has appropriate permission classes to secure access to resources, especially in nested contexts.\n\n### **f. Document Your API**\n\nUse tools like **Swagger** or **DRF-YASG** to generate API documentation, making it easier for developers to understand and use your nested endpoints.\n\n### **g. Handle Errors Gracefully**\n\nImplement robust error handling in your ViewSets to manage scenarios where parent resources do not exist or access is unauthorized.\n\n### **h. Consider Alternative Approaches When Necessary**\n\nIf nesting becomes too complex, explore alternative structures such as:\n\n- **Query Parameters**: Filter resources based on query parameters without nesting.\n- **Separate Endpoints**: Provide separate endpoints for related resources without hierarchical URLs.\n\n## 10. Alternatives to Nested Routers\n\nWhile nested routers are useful, they aren't always the best solution. Here are some alternatives:\n\n### **a. Flat Routers with Query Parameters**\n\nInstead of nesting, use flat URLs and filter child resources based on query parameters.\n\n**Example:**\n\n- `/books/?author_id=1/`\n\n**Pros:**\n\n- Simpler URL structure.\n- Easier to manage and understand.\n\n**Cons:**\n\n- Less intuitive in reflecting relationships.\n- May require more complex filtering logic.\n\n### **b. Hyperlinked Relationships**\n\nUse hyperlinked serializers to include links to related resources without nesting URLs.\n\n**Pros:**\n\n- Decouples URL structure from resource relationships.\n- Flexible and RESTful.\n\n**Cons:**\n\n- Less intuitive browsing through related resources via URL.\n\n### **c. Custom URL Patterns**\n\nDefine custom URL patterns tailored to specific needs rather than relying solely on nested routers.\n\n**Pros:**\n\n- Greater control over URL structure.\n- Can cater to complex or unique routing requirements.\n\n**Cons:**\n\n- More manual configuration.\n- Potential for inconsistency.\n\n### **d. Use DRF's `ViewSet` Without Routers**\n\nManually map URLs to ViewSet actions without using routers.\n\n**Pros:**\n\n- Full control over URL patterns.\n- Avoids potential complexities of nested routers.\n\n**Cons:**\n\n- Increased boilerplate code.\n- Potentially less scalable for large APIs.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"output-file":"nested_routers.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.27","comments":{"utterances":{"repo":"quarto-dev/quarto-web"}},"author":"Benedict Thekkel","theme":{"light":"flatly","dark":"darkly"},"description":"Nested Routers","skip_exec":true,"skip_showdoc":true,"title":"Nested Routers"},"extensions":{"book":{"multiFile":true}}},"gfm":{"identifier":{"display-name":"Github (GFM)","target-format":"gfm","base-format":"gfm"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"png","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":false,"output-ext":"md","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"variant":"+autolink_bare_uris+emoji+footnotes+gfm_auto_identifiers+pipe_tables+strikeout+task_lists+tex_math_dollars"},"pandoc":{"standalone":true,"default-image-extension":"png","to":"commonmark","output-file":"nested_routers.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"comments":{"utterances":{"repo":"quarto-dev/quarto-web"}},"description":"Nested Routers","skip_exec":true,"skip_showdoc":true,"title":"Nested Routers"}}},"projectFormats":["html","gfm"]}