{"title":"Celery","markdown":{"yaml":{"description":"**Celery** is an asynchronous task queue/job queue system based on distributed message passing. It’s widely used in Django and other Python web frameworks to manage background tasks, perform distributed computation, and handle scheduled tasks. Celery is particularly powerful for running time-consuming tasks asynchronously to improve user experience and system responsiveness.","output-file":"celery.html","skip_exec":true,"skip_showdoc":true,"title":"Celery"},"headingText":"1. **What is Celery?**","containsRefs":false,"markdown":"\n\n\n\n<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->\n\n\n**Celery** is a distributed system to process messages asynchronously by running tasks in the background. It uses a **message broker** to deliver messages between the main application and worker nodes. It is designed to handle distributed task processing at scale.\n\n### Key Features:\n- **Asynchronous Task Execution**: Run tasks in the background, freeing up your main application.\n- **Task Scheduling**: Execute tasks at specific intervals or after certain delays (like cron jobs).\n- **Distributed Processing**: Run tasks across multiple worker nodes for scalability and fault tolerance.\n- **Task Retrying**: Tasks can be automatically retried if they fail.\n\n### 2. **Celery Architecture**\n\n#### a. **Workers**\nWorkers are background processes that execute tasks. You can have multiple workers across different machines to handle tasks in parallel.\n\n#### b. **Message Broker**\nA message broker (such as **Redis**, **RabbitMQ**, or **Amazon SQS**) is used to send messages from your main application to Celery workers. The broker handles task queuing and routing.\n\n#### c. **Result Backend**\nThe result backend stores the results of tasks. Celery supports several backends like **Redis**, **Django ORM**, **AMQP**, **Memcached**, and **SQLAlchemy**.\n\n### 3. **Installation and Setup**\n\n#### a. **Install Celery**\n\nTo install Celery in your project, use `pip`:\n\n```bash\npip install celery\n```\n\n#### b. **Basic Celery Setup for a Django Project**\n\n1. **Create a `celery.py` file** in your Django project directory (where `settings.py` resides):\n\n   ```python\n   # project/celery.py\n   from __future__ import absolute_import, unicode_literals\n   import os\n   from celery import Celery\n\n   # set the default Django settings module for the 'celery' program.\n   os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'project.settings')\n\n   app = Celery('project')\n\n   # Using a string here means the worker doesn’t have to serialize\n   # the configuration object to child processes.\n   app.config_from_object('django.conf:settings', namespace='CELERY')\n\n   # Load task modules from all registered Django app configs.\n   app.autodiscover_tasks()\n   ```\n\n2. **Update `__init__.py`** to ensure that Celery is imported when Django starts.\n\n   ```python\n   # project/__init__.py\n\n   from __future__ import absolute_import, unicode_literals\n\n   # This will make sure the app is always imported when\n   # Django starts so that shared_task will use this app.\n   from .celery import app as celery_app\n\n   __all__ = ('celery_app',)\n   ```\n\n3. **Configure Celery in `settings.py`**:\n\n   Add the configuration for the message broker (for example, Redis):\n\n   ```python\n   # project/settings.py\n\n   # Celery settings\n   CELERY_BROKER_URL = 'redis://localhost:6379/0'  # Redis as message broker\n   CELERY_RESULT_BACKEND = 'redis://localhost:6379/0'  # Redis to store task results\n   CELERY_ACCEPT_CONTENT = ['json']\n   CELERY_TASK_SERIALIZER = 'json'\n   CELERY_RESULT_SERIALIZER = 'json'\n   CELERY_TIMEZONE = 'UTC'\n   ```\n\n#### c. **Starting Celery Workers**\n\nOnce you’ve configured Celery, you need to run the Celery workers to process the tasks. Run this command from the Django project root:\n\n```bash\ncelery -A project worker --loglevel=info\n```\n\nThis command starts a Celery worker that will process tasks defined in your project. The `--loglevel=info` flag ensures you see task output.\n\n### 4. **Defining and Executing Tasks**\n\nTasks in Celery are just Python functions that you register as tasks using the `@task` decorator. You can create tasks in any app within the Django project.\n\n#### a. **Defining a Task**\n\n```python\n# tasks.py in any Django app\n\nfrom celery import shared_task\nfrom time import sleep\n\n@shared_task\ndef add(x, y):\n    sleep(10)  # Simulate a time-consuming task\n    return x + y\n```\n\n- **`@shared_task`**: This decorator marks the function as a Celery task, meaning it can be executed asynchronously.\n\n#### b. **Calling a Task**\n\nTo execute a Celery task asynchronously, you use the `delay()` method:\n\n```python\nfrom .tasks import add\n\n# Call the task asynchronously\nresult = add.delay(4, 6)\n\n# You can also retrieve the result (if needed)\nprint(result.get())  # This will block until the task is done\n```\n\nThis will queue the `add` task, and Celery workers will execute it in the background.\n\n#### c. **Task Results**\n\nYou can track task execution status and retrieve the result using the task’s ID:\n\n```python\n# Retrieve the result using the task ID\nfrom celery.result import AsyncResult\n\nresult = AsyncResult(task_id)\nif result.successful():\n    print(result.result)\n```\n\n### 5. **Task Retries and Error Handling**\n\nCelery allows you to automatically retry tasks that fail due to transient errors.\n\n#### a. **Retrying a Task**\n\nTo make a task retryable, use the `retry()` method in the task function:\n\n```python\n@shared_task(bind=True, max_retries=3)\ndef example_task(self):\n    try:\n        # Simulate a task that may fail\n        risky_operation()\n    except SomeError as exc:\n        raise self.retry(exc=exc, countdown=5)\n```\n\n- **`max_retries=3`**: The task will be retried a maximum of 3 times.\n- **`countdown=5`**: The task will wait 5 seconds before retrying.\n\n#### b. **Error Handling**\n\nIf a task raises an exception, it can be caught and retried or handled with a fallback:\n\n```python\n@shared_task(bind=True)\ndef risky_task(self):\n    try:\n        risky_operation()\n    except Exception as exc:\n        self.update_state(state='FAILURE', meta={'error': str(exc)})\n        raise exc\n```\n\n- **`self.update_state()`**: Updates the task's state manually. You can store custom error metadata using the `meta` argument.\n\n### 6. **Periodic and Scheduled Tasks**\n\nYou can schedule tasks to run at specific times or intervals, similar to cron jobs.\n\n#### a. **Using Celery Beat**\n\n**Celery Beat** is a scheduler that kicks off tasks at regular intervals. It works alongside your Celery workers.\n\n1. **Install the necessary package**:\n\n   ```bash\n   pip install django-celery-beat\n   ```\n\n2. **Add `django_celery_beat` to your `INSTALLED_APPS`** in `settings.py`:\n\n   ```python\n   INSTALLED_APPS = [\n       # other apps\n       'django_celery_beat',\n   ]\n   ```\n\n3. **Run migrations** for Celery Beat:\n\n   ```bash\n   python manage.py migrate django_celery_beat\n   ```\n\n4. **Configure a Periodic Task** using the Django Admin or in code:\n\n   Example of a periodic task running every 10 minutes:\n\n   ```python\n   from django_celery_beat.models import PeriodicTask, IntervalSchedule\n\n   # Create an interval schedule (every 10 minutes)\n   schedule, created = IntervalSchedule.objects.get_or_create(\n       every=10,\n       period=IntervalSchedule.MINUTES,\n   )\n\n   # Create the periodic task\n   PeriodicTask.objects.create(\n       interval=schedule,                  # Use the schedule created above\n       name='My periodic task',\n       task='myapp.tasks.my_task',  # The name of the task function\n   )\n   ```\n\n5. **Start the Celery Beat Scheduler**:\n\n   ```bash\n   celery -A project beat --loglevel=info\n   ```\n\n   This command will run the scheduler, which triggers periodic tasks based on your schedule.\n\n#### b. **Using the `crontab` Scheduler**\n\nYou can also configure tasks to run at specific times using cron-like syntax:\n\n```python\nfrom celery.schedules import crontab\n\napp.conf.beat_schedule = {\n    'task_name': {\n        'task': 'myapp.tasks.my_task',\n        'schedule': crontab(hour=7, minute=30, day_of_week=1),  # Every Monday at 7:30 AM\n    },\n}\n```\n\n### 7. **Optimizing Celery for Production**\n\n#### a. **Concurrency**\nYou can control how many worker processes or threads Celery spawns using the `--concurrency` option when starting workers:\n\n```bash\ncelery -A project worker --concurrency=4\n```\n\nThis will start 4 worker processes.\n\n#### b. **Prefetch Limit**\nCelery workers can fetch multiple tasks in advance, but this may overload workers in some cases. You can limit the number of prefetched tasks with `CELERYD_PREFETCH_MULTIPLIER`:\n\n```python\napp.conf.worker_prefetch_multiplier = 1  # Pref\n\netch only 1 task at a time\n```\n\n#### c. **Task Time Limits**\nIf a task takes too long, you can set time limits to prevent worker exhaustion:\n\n```python\napp.conf.task_soft_time_limit = 60  # Raise exception after 60 seconds\napp.conf.task_time_limit = 120      # Hard limit (kill task after 120 seconds)\n```\n\n#### d. **Monitoring and Admin**\nUse **Flower**, a web-based tool to monitor Celery workers and tasks:\n\n1. Install Flower:\n\n   ```bash\n   pip install flower\n   ```\n\n2. Start Flower:\n\n   ```bash\n   celery -A project flower\n   ```\n\n   Flower provides a web interface that shows the current status of workers, tasks, and queues. You can view task progress, task failures, and retry counts.\n\n### 8. **Broker Options**\n\nCelery supports a wide range of message brokers, including:\n\n- **Redis**: A simple key-value store that can act as a message broker.\n- **RabbitMQ**: A robust, feature-rich message broker that supports advanced features like routing and exchanges.\n- **Amazon SQS**: A scalable message queue service.\n\n#### Redis Example:\n\n```python\nCELERY_BROKER_URL = 'redis://localhost:6379/0'\nCELERY_RESULT_BACKEND = 'redis://localhost:6379/0'\n```\n\n#### RabbitMQ Example:\n\n```python\nCELERY_BROKER_URL = 'amqp://guest:guest@localhost:5672//'\n```\n\n### 9. **Best Practices**\n\n- **Use Task Queues**: Use task queues to categorize and separate different types of tasks, especially if they have different priority or resource requirements.\n  \n  Example:\n  ```python\n  celery -A project worker -Q queue_name\n  ```\n\n- **Idempotent Tasks**: Ensure tasks are idempotent, meaning they can run multiple times without unintended side effects. This is essential because Celery retries tasks after failures.\n  \n- **Error Handling**: Always handle potential errors inside tasks using `try/except` and consider using `retry()` for transient issues.\n\n- **Monitor Tasks**: Use monitoring tools like **Flower** or **Prometheus** to track worker health and task performance.\n","srcMarkdownNoYaml":"\n\n\n\n<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->\n\n### 1. **What is Celery?**\n\n**Celery** is a distributed system to process messages asynchronously by running tasks in the background. It uses a **message broker** to deliver messages between the main application and worker nodes. It is designed to handle distributed task processing at scale.\n\n### Key Features:\n- **Asynchronous Task Execution**: Run tasks in the background, freeing up your main application.\n- **Task Scheduling**: Execute tasks at specific intervals or after certain delays (like cron jobs).\n- **Distributed Processing**: Run tasks across multiple worker nodes for scalability and fault tolerance.\n- **Task Retrying**: Tasks can be automatically retried if they fail.\n\n### 2. **Celery Architecture**\n\n#### a. **Workers**\nWorkers are background processes that execute tasks. You can have multiple workers across different machines to handle tasks in parallel.\n\n#### b. **Message Broker**\nA message broker (such as **Redis**, **RabbitMQ**, or **Amazon SQS**) is used to send messages from your main application to Celery workers. The broker handles task queuing and routing.\n\n#### c. **Result Backend**\nThe result backend stores the results of tasks. Celery supports several backends like **Redis**, **Django ORM**, **AMQP**, **Memcached**, and **SQLAlchemy**.\n\n### 3. **Installation and Setup**\n\n#### a. **Install Celery**\n\nTo install Celery in your project, use `pip`:\n\n```bash\npip install celery\n```\n\n#### b. **Basic Celery Setup for a Django Project**\n\n1. **Create a `celery.py` file** in your Django project directory (where `settings.py` resides):\n\n   ```python\n   # project/celery.py\n   from __future__ import absolute_import, unicode_literals\n   import os\n   from celery import Celery\n\n   # set the default Django settings module for the 'celery' program.\n   os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'project.settings')\n\n   app = Celery('project')\n\n   # Using a string here means the worker doesn’t have to serialize\n   # the configuration object to child processes.\n   app.config_from_object('django.conf:settings', namespace='CELERY')\n\n   # Load task modules from all registered Django app configs.\n   app.autodiscover_tasks()\n   ```\n\n2. **Update `__init__.py`** to ensure that Celery is imported when Django starts.\n\n   ```python\n   # project/__init__.py\n\n   from __future__ import absolute_import, unicode_literals\n\n   # This will make sure the app is always imported when\n   # Django starts so that shared_task will use this app.\n   from .celery import app as celery_app\n\n   __all__ = ('celery_app',)\n   ```\n\n3. **Configure Celery in `settings.py`**:\n\n   Add the configuration for the message broker (for example, Redis):\n\n   ```python\n   # project/settings.py\n\n   # Celery settings\n   CELERY_BROKER_URL = 'redis://localhost:6379/0'  # Redis as message broker\n   CELERY_RESULT_BACKEND = 'redis://localhost:6379/0'  # Redis to store task results\n   CELERY_ACCEPT_CONTENT = ['json']\n   CELERY_TASK_SERIALIZER = 'json'\n   CELERY_RESULT_SERIALIZER = 'json'\n   CELERY_TIMEZONE = 'UTC'\n   ```\n\n#### c. **Starting Celery Workers**\n\nOnce you’ve configured Celery, you need to run the Celery workers to process the tasks. Run this command from the Django project root:\n\n```bash\ncelery -A project worker --loglevel=info\n```\n\nThis command starts a Celery worker that will process tasks defined in your project. The `--loglevel=info` flag ensures you see task output.\n\n### 4. **Defining and Executing Tasks**\n\nTasks in Celery are just Python functions that you register as tasks using the `@task` decorator. You can create tasks in any app within the Django project.\n\n#### a. **Defining a Task**\n\n```python\n# tasks.py in any Django app\n\nfrom celery import shared_task\nfrom time import sleep\n\n@shared_task\ndef add(x, y):\n    sleep(10)  # Simulate a time-consuming task\n    return x + y\n```\n\n- **`@shared_task`**: This decorator marks the function as a Celery task, meaning it can be executed asynchronously.\n\n#### b. **Calling a Task**\n\nTo execute a Celery task asynchronously, you use the `delay()` method:\n\n```python\nfrom .tasks import add\n\n# Call the task asynchronously\nresult = add.delay(4, 6)\n\n# You can also retrieve the result (if needed)\nprint(result.get())  # This will block until the task is done\n```\n\nThis will queue the `add` task, and Celery workers will execute it in the background.\n\n#### c. **Task Results**\n\nYou can track task execution status and retrieve the result using the task’s ID:\n\n```python\n# Retrieve the result using the task ID\nfrom celery.result import AsyncResult\n\nresult = AsyncResult(task_id)\nif result.successful():\n    print(result.result)\n```\n\n### 5. **Task Retries and Error Handling**\n\nCelery allows you to automatically retry tasks that fail due to transient errors.\n\n#### a. **Retrying a Task**\n\nTo make a task retryable, use the `retry()` method in the task function:\n\n```python\n@shared_task(bind=True, max_retries=3)\ndef example_task(self):\n    try:\n        # Simulate a task that may fail\n        risky_operation()\n    except SomeError as exc:\n        raise self.retry(exc=exc, countdown=5)\n```\n\n- **`max_retries=3`**: The task will be retried a maximum of 3 times.\n- **`countdown=5`**: The task will wait 5 seconds before retrying.\n\n#### b. **Error Handling**\n\nIf a task raises an exception, it can be caught and retried or handled with a fallback:\n\n```python\n@shared_task(bind=True)\ndef risky_task(self):\n    try:\n        risky_operation()\n    except Exception as exc:\n        self.update_state(state='FAILURE', meta={'error': str(exc)})\n        raise exc\n```\n\n- **`self.update_state()`**: Updates the task's state manually. You can store custom error metadata using the `meta` argument.\n\n### 6. **Periodic and Scheduled Tasks**\n\nYou can schedule tasks to run at specific times or intervals, similar to cron jobs.\n\n#### a. **Using Celery Beat**\n\n**Celery Beat** is a scheduler that kicks off tasks at regular intervals. It works alongside your Celery workers.\n\n1. **Install the necessary package**:\n\n   ```bash\n   pip install django-celery-beat\n   ```\n\n2. **Add `django_celery_beat` to your `INSTALLED_APPS`** in `settings.py`:\n\n   ```python\n   INSTALLED_APPS = [\n       # other apps\n       'django_celery_beat',\n   ]\n   ```\n\n3. **Run migrations** for Celery Beat:\n\n   ```bash\n   python manage.py migrate django_celery_beat\n   ```\n\n4. **Configure a Periodic Task** using the Django Admin or in code:\n\n   Example of a periodic task running every 10 minutes:\n\n   ```python\n   from django_celery_beat.models import PeriodicTask, IntervalSchedule\n\n   # Create an interval schedule (every 10 minutes)\n   schedule, created = IntervalSchedule.objects.get_or_create(\n       every=10,\n       period=IntervalSchedule.MINUTES,\n   )\n\n   # Create the periodic task\n   PeriodicTask.objects.create(\n       interval=schedule,                  # Use the schedule created above\n       name='My periodic task',\n       task='myapp.tasks.my_task',  # The name of the task function\n   )\n   ```\n\n5. **Start the Celery Beat Scheduler**:\n\n   ```bash\n   celery -A project beat --loglevel=info\n   ```\n\n   This command will run the scheduler, which triggers periodic tasks based on your schedule.\n\n#### b. **Using the `crontab` Scheduler**\n\nYou can also configure tasks to run at specific times using cron-like syntax:\n\n```python\nfrom celery.schedules import crontab\n\napp.conf.beat_schedule = {\n    'task_name': {\n        'task': 'myapp.tasks.my_task',\n        'schedule': crontab(hour=7, minute=30, day_of_week=1),  # Every Monday at 7:30 AM\n    },\n}\n```\n\n### 7. **Optimizing Celery for Production**\n\n#### a. **Concurrency**\nYou can control how many worker processes or threads Celery spawns using the `--concurrency` option when starting workers:\n\n```bash\ncelery -A project worker --concurrency=4\n```\n\nThis will start 4 worker processes.\n\n#### b. **Prefetch Limit**\nCelery workers can fetch multiple tasks in advance, but this may overload workers in some cases. You can limit the number of prefetched tasks with `CELERYD_PREFETCH_MULTIPLIER`:\n\n```python\napp.conf.worker_prefetch_multiplier = 1  # Pref\n\netch only 1 task at a time\n```\n\n#### c. **Task Time Limits**\nIf a task takes too long, you can set time limits to prevent worker exhaustion:\n\n```python\napp.conf.task_soft_time_limit = 60  # Raise exception after 60 seconds\napp.conf.task_time_limit = 120      # Hard limit (kill task after 120 seconds)\n```\n\n#### d. **Monitoring and Admin**\nUse **Flower**, a web-based tool to monitor Celery workers and tasks:\n\n1. Install Flower:\n\n   ```bash\n   pip install flower\n   ```\n\n2. Start Flower:\n\n   ```bash\n   celery -A project flower\n   ```\n\n   Flower provides a web interface that shows the current status of workers, tasks, and queues. You can view task progress, task failures, and retry counts.\n\n### 8. **Broker Options**\n\nCelery supports a wide range of message brokers, including:\n\n- **Redis**: A simple key-value store that can act as a message broker.\n- **RabbitMQ**: A robust, feature-rich message broker that supports advanced features like routing and exchanges.\n- **Amazon SQS**: A scalable message queue service.\n\n#### Redis Example:\n\n```python\nCELERY_BROKER_URL = 'redis://localhost:6379/0'\nCELERY_RESULT_BACKEND = 'redis://localhost:6379/0'\n```\n\n#### RabbitMQ Example:\n\n```python\nCELERY_BROKER_URL = 'amqp://guest:guest@localhost:5672//'\n```\n\n### 9. **Best Practices**\n\n- **Use Task Queues**: Use task queues to categorize and separate different types of tasks, especially if they have different priority or resource requirements.\n  \n  Example:\n  ```python\n  celery -A project worker -Q queue_name\n  ```\n\n- **Idempotent Tasks**: Ensure tasks are idempotent, meaning they can run multiple times without unintended side effects. This is essential because Celery retries tasks after failures.\n  \n- **Error Handling**: Always handle potential errors inside tasks using `try/except` and consider using `retry()` for transient issues.\n\n- **Monitor Tasks**: Use monitoring tools like **Flower** or **Prometheus** to track worker health and task performance.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"output-file":"celery.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.27","comments":{"utterances":{"repo":"quarto-dev/quarto-web"}},"author":"Benedict Thekkel","theme":{"light":"flatly","dark":"darkly"},"description":"**Celery** is an asynchronous task queue/job queue system based on distributed message passing. It’s widely used in Django and other Python web frameworks to manage background tasks, perform distributed computation, and handle scheduled tasks. Celery is particularly powerful for running time-consuming tasks asynchronously to improve user experience and system responsiveness.","skip_exec":true,"skip_showdoc":true,"title":"Celery"},"extensions":{"book":{"multiFile":true}}},"gfm":{"identifier":{"display-name":"Github (GFM)","target-format":"gfm","base-format":"gfm"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"png","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":false,"output-ext":"md","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"variant":"+autolink_bare_uris+emoji+footnotes+gfm_auto_identifiers+pipe_tables+strikeout+task_lists+tex_math_dollars"},"pandoc":{"standalone":true,"default-image-extension":"png","to":"commonmark","output-file":"celery.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"comments":{"utterances":{"repo":"quarto-dev/quarto-web"}},"description":"**Celery** is an asynchronous task queue/job queue system based on distributed message passing. It’s widely used in Django and other Python web frameworks to manage background tasks, perform distributed computation, and handle scheduled tasks. Celery is particularly powerful for running time-consuming tasks asynchronously to improve user experience and system responsiveness.","skip_exec":true,"skip_showdoc":true,"title":"Celery"}}},"projectFormats":["html","gfm"]}