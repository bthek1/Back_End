{"title":"django_q","markdown":{"yaml":{"description":"Django-Q is a task queue and scheduler designed for Django, allowing you to run tasks asynchronously in the background, schedule recurring tasks, and handle distributed task queues. It’s an alternative to tools like Celery, providing a simpler, more Pythonic interface for handling asynchronous tasks in Django projects.","output-file":"django_q.html","skip_exec":true,"skip_showdoc":true,"title":"django_q"},"headingText":"1. **Core Concepts of Django-Q**","containsRefs":false,"markdown":"\n\n\n\n<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->\n\n\n- **Task Queue**: You can offload long-running or resource-heavy tasks to the background using Django-Q. These tasks are processed asynchronously without blocking the main Django app.\n- **Scheduling**: Django-Q has built-in support for periodic or scheduled tasks, similar to cron jobs.\n- **Result Handling**: It supports tracking the result of tasks and retrieving them later.\n- **Clusters**: Django-Q operates with \"clusters\" of worker processes that handle tasks in parallel, allowing you to scale task processing horizontally.\n- **Multiple Backends**: Django-Q supports Redis, ORM, and other storage options for task persistence and broker functionality.\n- **Failover and Recovery**: It has robust task recovery mechanisms, ensuring tasks are retried in case of failure.\n\n### 2. **Installation**\n\nTo install **Django-Q**, you can use `pip`:\n\n```bash\npip install django-q\n```\n\nOnce installed, add `django_q` to your `INSTALLED_APPS` in `settings.py`:\n\n```python\nINSTALLED_APPS = [\n    # Other apps...\n    'django_q',\n]\n```\n\nAfter that, run the necessary migrations:\n\n```bash\npython manage.py migrate\n```\n\n### 3. **Basic Setup**\n\nAfter installation, configure Django-Q in `settings.py`. You need to define the broker, which will handle communication between Django and the background workers. Common brokers include **Redis** and **Django ORM**.\n\n#### Example configuration using Redis:\n\n```python\nQ_CLUSTER = {\n    'name': 'DjangoQCluster',\n    'workers': 4,  # Number of workers to handle tasks\n    'recycle': 500,  # How many tasks before a worker is recycled\n    'timeout': 60,  # Maximum time to wait for a task\n    'queue_limit': 50,  # Limit the number of tasks in the queue\n    'bulk': 10,  # Process tasks in bulk\n    'orm': 'default',  # Use Django ORM for task storage\n    'redis': {\n        'host': 'localhost',\n        'port': 6379,\n        'db': 0,\n    }\n}\n```\n\nFor **Django ORM** as the broker (no external dependencies):\n\n```python\nQ_CLUSTER = {\n    'name': 'DjangoQCluster',\n    'workers': 4,\n    'timeout': 60,\n    'queue_limit': 50,\n    'bulk': 10,\n    'orm': 'default'  # Use Django ORM to store tasks and results\n}\n```\n\n### 4. **Running Django-Q**\n\nStart Django-Q’s cluster to begin processing tasks by running:\n\n```bash\npython manage.py qcluster\n```\n\nThe cluster will spawn worker processes that consume tasks from the queue and execute them in the background.\n\n### 5. **Asynchronous Tasks**\n\nTo define an asynchronous task, you create a Python function and call it asynchronously using the `async_task()` function.\n\n#### Example:\n\n```python\nfrom django_q.tasks import async_task\n\ndef send_email(user_id):\n    # Send email logic here\n    print(f'Sending email to user {user_id}')\n\n# Running the task asynchronously\nasync_task('myapp.tasks.send_email', user_id)\n```\n\n- **`async_task()`**: Schedules the function to be executed in the background.\n\n#### Tracking Task Results\n\nYou can track the result of a task if needed. Use the `result` function to retrieve the result:\n\n```python\nfrom django_q.tasks import result\n\ntask_id = async_task('myapp.tasks.send_email', user_id)\n\n# Later in the code, you can fetch the result\nres = result(task_id)\nif res:\n    print(f'Task Result: {res}')\n```\n\nIf the task fails, Django-Q will retry the task until it either succeeds or exceeds the retry limit.\n\n### 6. **Scheduled Tasks**\n\nDjango-Q has built-in support for **scheduled tasks** (periodic tasks). You can schedule tasks to run at specific intervals, similar to cron jobs.\n\n#### Example:\n\n```python\nfrom django_q.models import Schedule\n\n# Schedule a task to run every minute\nSchedule.objects.create(\n    func='myapp.tasks.send_email',\n    args='user_id',\n    schedule_type=Schedule.MINUTES,\n    minutes=1,\n    repeats=-1,  # Repeat indefinitely\n)\n```\n\n- **`Schedule.MINUTES`**: Schedule type to run tasks periodically (other options include `Schedule.HOURLY`, `Schedule.DAILY`, `Schedule.WEEKLY`).\n- **`repeats`**: Set to `-1` to repeat indefinitely, or to a positive integer to repeat a fixed number of times.\n\n#### Available Schedule Types:\n- **One-time task**: `Schedule.ONCE`\n- **Repeating tasks**:\n  - `Schedule.MINUTES`\n  - `Schedule.HOURLY`\n  - `Schedule.DAILY`\n  - `Schedule.WEEKLY`\n  - `Schedule.MONTHLY`\n\n### 7. **Using ORM as the Broker**\n\nIf you prefer not to use Redis or another external service, Django-Q can use the Django ORM as the broker for storing tasks. This is a great option for simpler setups or testing environments.\n\nTo use the ORM as the broker, update your settings:\n\n```python\nQ_CLUSTER = {\n    'name': 'DjangoQCluster',\n    'workers': 4,\n    'timeout': 60,\n    'queue_limit': 50,\n    'orm': 'default'  # ORM mode\n}\n```\n\nTasks and results will now be stored in the database, using Django models.\n\n### 8. **Task Retry and Timeout**\n\nDjango-Q automatically retries tasks if they fail, with configurable retry limits and timeouts.\n\n- **Timeout**: Defined in the cluster configuration (`timeout` key). If a task exceeds this time, it is marked as failed and retried.\n- **Retries**: If a task fails, Django-Q retries the task based on the retry policy you define.\n\n#### Example:\n\n```python\nQ_CLUSTER = {\n    'timeout': 60,  # Tasks timeout after 60 seconds\n    'retry': 2,  # Retries each task twice if it fails\n}\n```\n\n### 9. **Task Chaining and Grouping**\n\nYou can chain multiple tasks together or group tasks to run them in parallel.\n\n#### Task Chaining:\n\n```python\nfrom django_q.tasks import chain\n\n# Chain tasks, one task will be executed after the previous one completes\nchain('myapp.tasks.task_one', 'myapp.tasks.task_two', args=(1,))\n```\n\n#### Task Grouping (Run in Parallel):\n\n```python\nfrom django_q.tasks import async_task, result_group\n\ngroup = async_task('myapp.tasks.task_one', 1, group='task_group')\nasync_task('myapp.tasks.task_two', 2, group='task_group')\n\n# Retrieve the results for the group\nresults = result_group('task_group')\nfor r in results:\n    print(f'Task Result: {r}')\n```\n\n### 10. **Task Priority**\n\nDjango-Q supports priority queues, where higher priority tasks are processed before lower-priority ones.\n\n#### Example:\n\n```python\n# Set a high priority for the task\nasync_task('myapp.tasks.send_email', user_id, priority=1)\n```\n\nLower numbers have higher priority (1 being the highest).\n\n### 11. **Monitoring and Admin**\n\nDjango-Q provides a Django Admin interface for monitoring tasks, schedules, and clusters. You can view:\n\n- **Failed tasks**\n- **Running tasks**\n- **Scheduled tasks**\n- **Task results**\n\nIn your `admin.py`:\n\n```python\nfrom django_q.admin import TaskAdmin, ScheduleAdmin\nfrom django_q.models import Task, Schedule\n\nadmin.site.register(Task, TaskAdmin)\nadmin.site.register(Schedule, ScheduleAdmin)\n```\n\nThis will give you visibility into the task queue and schedules via the Django Admin.\n\n### 12. **Advanced Settings**\n\nDjango-Q comes with a variety of settings to fine-tune task processing and behavior.\n\n#### Advanced Options:\n\n```python\nQ_CLUSTER = {\n    'name': 'DjangoQCluster',\n    'workers': 4,  # Number of worker processes\n    'timeout': 60,  # Time limit per task\n    'recycle': 500,  # Restart worker after processing this many tasks\n    'compress': True,  # Compress task data to reduce memory usage\n    'save_limit': 100,  # Only keep 100 task results in the database\n    'group_save_limit': 100,  # Limit the number of task group results\n    'queue_limit': 50,  # Maximum number of tasks in the queue\n    'cpu_affinity': 1,  # Allocate one core for worker processing\n    'log_level': 'DEBUG',  # Log level (DEBUG, INFO, WARNING, etc.)\n}\n```\n\n- **`recycle`**: Recycles workers after a specified number of tasks to avoid memory leaks.\n- **`compress`**: Compresses task data to reduce memory footprint.\n- **`save_limit`**: Limits how many task results are saved (useful for reducing database size).\n- **`queue_limit`**: Prevents too many tasks from being queued up\n\n.\n\n### 13. **Failover and High Availability**\n\nDjango-Q offers **failover support** in case a task or worker process fails. It retries tasks and restarts failed workers as needed.\n\n- **Distributed Mode**: You can deploy Django-Q in a distributed mode by running multiple clusters across different servers. This allows horizontal scaling and high availability.\n\n### 14. **Logging and Debugging**\n\nDjango-Q provides detailed logging options, which you can configure in your settings:\n\n```python\nQ_CLUSTER = {\n    'log_level': 'DEBUG',  # DEBUG, INFO, WARNING, ERROR\n    'log_file': '/path/to/your/logfile.log',  # Specify a log file\n}\n```\n\nLogs include task execution details, errors, and retries, which can help in debugging and monitoring your task queue.\n\n### 15. **Django Signals**\n\nDjango-Q integrates with Django's signals framework. For example, you can trigger tasks based on model signals like `post_save`:\n\n```python\nfrom django.db.models.signals import post_save\nfrom django.dispatch import receiver\nfrom django_q.tasks import async_task\nfrom myapp.models import MyModel\n\n@receiver(post_save, sender=MyModel)\ndef my_model_post_save(sender, instance, **kwargs):\n    # Trigger async task when a MyModel object is saved\n    async_task('myapp.tasks.process_data', instance.id)\n```\n\n### Conclusion\n\n**Django-Q** is a powerful and flexible task queue and scheduler for Django applications, providing asynchronous task execution, scheduling, and result tracking with ease. It is particularly well-suited for smaller to mid-sized projects, or as a simpler alternative to Celery, thanks to its minimal configuration requirements and built-in ORM support.\n","srcMarkdownNoYaml":"\n\n\n\n<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->\n\n### 1. **Core Concepts of Django-Q**\n\n- **Task Queue**: You can offload long-running or resource-heavy tasks to the background using Django-Q. These tasks are processed asynchronously without blocking the main Django app.\n- **Scheduling**: Django-Q has built-in support for periodic or scheduled tasks, similar to cron jobs.\n- **Result Handling**: It supports tracking the result of tasks and retrieving them later.\n- **Clusters**: Django-Q operates with \"clusters\" of worker processes that handle tasks in parallel, allowing you to scale task processing horizontally.\n- **Multiple Backends**: Django-Q supports Redis, ORM, and other storage options for task persistence and broker functionality.\n- **Failover and Recovery**: It has robust task recovery mechanisms, ensuring tasks are retried in case of failure.\n\n### 2. **Installation**\n\nTo install **Django-Q**, you can use `pip`:\n\n```bash\npip install django-q\n```\n\nOnce installed, add `django_q` to your `INSTALLED_APPS` in `settings.py`:\n\n```python\nINSTALLED_APPS = [\n    # Other apps...\n    'django_q',\n]\n```\n\nAfter that, run the necessary migrations:\n\n```bash\npython manage.py migrate\n```\n\n### 3. **Basic Setup**\n\nAfter installation, configure Django-Q in `settings.py`. You need to define the broker, which will handle communication between Django and the background workers. Common brokers include **Redis** and **Django ORM**.\n\n#### Example configuration using Redis:\n\n```python\nQ_CLUSTER = {\n    'name': 'DjangoQCluster',\n    'workers': 4,  # Number of workers to handle tasks\n    'recycle': 500,  # How many tasks before a worker is recycled\n    'timeout': 60,  # Maximum time to wait for a task\n    'queue_limit': 50,  # Limit the number of tasks in the queue\n    'bulk': 10,  # Process tasks in bulk\n    'orm': 'default',  # Use Django ORM for task storage\n    'redis': {\n        'host': 'localhost',\n        'port': 6379,\n        'db': 0,\n    }\n}\n```\n\nFor **Django ORM** as the broker (no external dependencies):\n\n```python\nQ_CLUSTER = {\n    'name': 'DjangoQCluster',\n    'workers': 4,\n    'timeout': 60,\n    'queue_limit': 50,\n    'bulk': 10,\n    'orm': 'default'  # Use Django ORM to store tasks and results\n}\n```\n\n### 4. **Running Django-Q**\n\nStart Django-Q’s cluster to begin processing tasks by running:\n\n```bash\npython manage.py qcluster\n```\n\nThe cluster will spawn worker processes that consume tasks from the queue and execute them in the background.\n\n### 5. **Asynchronous Tasks**\n\nTo define an asynchronous task, you create a Python function and call it asynchronously using the `async_task()` function.\n\n#### Example:\n\n```python\nfrom django_q.tasks import async_task\n\ndef send_email(user_id):\n    # Send email logic here\n    print(f'Sending email to user {user_id}')\n\n# Running the task asynchronously\nasync_task('myapp.tasks.send_email', user_id)\n```\n\n- **`async_task()`**: Schedules the function to be executed in the background.\n\n#### Tracking Task Results\n\nYou can track the result of a task if needed. Use the `result` function to retrieve the result:\n\n```python\nfrom django_q.tasks import result\n\ntask_id = async_task('myapp.tasks.send_email', user_id)\n\n# Later in the code, you can fetch the result\nres = result(task_id)\nif res:\n    print(f'Task Result: {res}')\n```\n\nIf the task fails, Django-Q will retry the task until it either succeeds or exceeds the retry limit.\n\n### 6. **Scheduled Tasks**\n\nDjango-Q has built-in support for **scheduled tasks** (periodic tasks). You can schedule tasks to run at specific intervals, similar to cron jobs.\n\n#### Example:\n\n```python\nfrom django_q.models import Schedule\n\n# Schedule a task to run every minute\nSchedule.objects.create(\n    func='myapp.tasks.send_email',\n    args='user_id',\n    schedule_type=Schedule.MINUTES,\n    minutes=1,\n    repeats=-1,  # Repeat indefinitely\n)\n```\n\n- **`Schedule.MINUTES`**: Schedule type to run tasks periodically (other options include `Schedule.HOURLY`, `Schedule.DAILY`, `Schedule.WEEKLY`).\n- **`repeats`**: Set to `-1` to repeat indefinitely, or to a positive integer to repeat a fixed number of times.\n\n#### Available Schedule Types:\n- **One-time task**: `Schedule.ONCE`\n- **Repeating tasks**:\n  - `Schedule.MINUTES`\n  - `Schedule.HOURLY`\n  - `Schedule.DAILY`\n  - `Schedule.WEEKLY`\n  - `Schedule.MONTHLY`\n\n### 7. **Using ORM as the Broker**\n\nIf you prefer not to use Redis or another external service, Django-Q can use the Django ORM as the broker for storing tasks. This is a great option for simpler setups or testing environments.\n\nTo use the ORM as the broker, update your settings:\n\n```python\nQ_CLUSTER = {\n    'name': 'DjangoQCluster',\n    'workers': 4,\n    'timeout': 60,\n    'queue_limit': 50,\n    'orm': 'default'  # ORM mode\n}\n```\n\nTasks and results will now be stored in the database, using Django models.\n\n### 8. **Task Retry and Timeout**\n\nDjango-Q automatically retries tasks if they fail, with configurable retry limits and timeouts.\n\n- **Timeout**: Defined in the cluster configuration (`timeout` key). If a task exceeds this time, it is marked as failed and retried.\n- **Retries**: If a task fails, Django-Q retries the task based on the retry policy you define.\n\n#### Example:\n\n```python\nQ_CLUSTER = {\n    'timeout': 60,  # Tasks timeout after 60 seconds\n    'retry': 2,  # Retries each task twice if it fails\n}\n```\n\n### 9. **Task Chaining and Grouping**\n\nYou can chain multiple tasks together or group tasks to run them in parallel.\n\n#### Task Chaining:\n\n```python\nfrom django_q.tasks import chain\n\n# Chain tasks, one task will be executed after the previous one completes\nchain('myapp.tasks.task_one', 'myapp.tasks.task_two', args=(1,))\n```\n\n#### Task Grouping (Run in Parallel):\n\n```python\nfrom django_q.tasks import async_task, result_group\n\ngroup = async_task('myapp.tasks.task_one', 1, group='task_group')\nasync_task('myapp.tasks.task_two', 2, group='task_group')\n\n# Retrieve the results for the group\nresults = result_group('task_group')\nfor r in results:\n    print(f'Task Result: {r}')\n```\n\n### 10. **Task Priority**\n\nDjango-Q supports priority queues, where higher priority tasks are processed before lower-priority ones.\n\n#### Example:\n\n```python\n# Set a high priority for the task\nasync_task('myapp.tasks.send_email', user_id, priority=1)\n```\n\nLower numbers have higher priority (1 being the highest).\n\n### 11. **Monitoring and Admin**\n\nDjango-Q provides a Django Admin interface for monitoring tasks, schedules, and clusters. You can view:\n\n- **Failed tasks**\n- **Running tasks**\n- **Scheduled tasks**\n- **Task results**\n\nIn your `admin.py`:\n\n```python\nfrom django_q.admin import TaskAdmin, ScheduleAdmin\nfrom django_q.models import Task, Schedule\n\nadmin.site.register(Task, TaskAdmin)\nadmin.site.register(Schedule, ScheduleAdmin)\n```\n\nThis will give you visibility into the task queue and schedules via the Django Admin.\n\n### 12. **Advanced Settings**\n\nDjango-Q comes with a variety of settings to fine-tune task processing and behavior.\n\n#### Advanced Options:\n\n```python\nQ_CLUSTER = {\n    'name': 'DjangoQCluster',\n    'workers': 4,  # Number of worker processes\n    'timeout': 60,  # Time limit per task\n    'recycle': 500,  # Restart worker after processing this many tasks\n    'compress': True,  # Compress task data to reduce memory usage\n    'save_limit': 100,  # Only keep 100 task results in the database\n    'group_save_limit': 100,  # Limit the number of task group results\n    'queue_limit': 50,  # Maximum number of tasks in the queue\n    'cpu_affinity': 1,  # Allocate one core for worker processing\n    'log_level': 'DEBUG',  # Log level (DEBUG, INFO, WARNING, etc.)\n}\n```\n\n- **`recycle`**: Recycles workers after a specified number of tasks to avoid memory leaks.\n- **`compress`**: Compresses task data to reduce memory footprint.\n- **`save_limit`**: Limits how many task results are saved (useful for reducing database size).\n- **`queue_limit`**: Prevents too many tasks from being queued up\n\n.\n\n### 13. **Failover and High Availability**\n\nDjango-Q offers **failover support** in case a task or worker process fails. It retries tasks and restarts failed workers as needed.\n\n- **Distributed Mode**: You can deploy Django-Q in a distributed mode by running multiple clusters across different servers. This allows horizontal scaling and high availability.\n\n### 14. **Logging and Debugging**\n\nDjango-Q provides detailed logging options, which you can configure in your settings:\n\n```python\nQ_CLUSTER = {\n    'log_level': 'DEBUG',  # DEBUG, INFO, WARNING, ERROR\n    'log_file': '/path/to/your/logfile.log',  # Specify a log file\n}\n```\n\nLogs include task execution details, errors, and retries, which can help in debugging and monitoring your task queue.\n\n### 15. **Django Signals**\n\nDjango-Q integrates with Django's signals framework. For example, you can trigger tasks based on model signals like `post_save`:\n\n```python\nfrom django.db.models.signals import post_save\nfrom django.dispatch import receiver\nfrom django_q.tasks import async_task\nfrom myapp.models import MyModel\n\n@receiver(post_save, sender=MyModel)\ndef my_model_post_save(sender, instance, **kwargs):\n    # Trigger async task when a MyModel object is saved\n    async_task('myapp.tasks.process_data', instance.id)\n```\n\n### Conclusion\n\n**Django-Q** is a powerful and flexible task queue and scheduler for Django applications, providing asynchronous task execution, scheduling, and result tracking with ease. It is particularly well-suited for smaller to mid-sized projects, or as a simpler alternative to Celery, thanks to its minimal configuration requirements and built-in ORM support.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"output-file":"django_q.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.27","comments":{"utterances":{"repo":"quarto-dev/quarto-web"}},"author":"Benedict Thekkel","theme":{"light":"flatly","dark":"darkly"},"description":"Django-Q is a task queue and scheduler designed for Django, allowing you to run tasks asynchronously in the background, schedule recurring tasks, and handle distributed task queues. It’s an alternative to tools like Celery, providing a simpler, more Pythonic interface for handling asynchronous tasks in Django projects.","skip_exec":true,"skip_showdoc":true,"title":"django_q"},"extensions":{"book":{"multiFile":true}}},"gfm":{"identifier":{"display-name":"Github (GFM)","target-format":"gfm","base-format":"gfm"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"png","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":false,"output-ext":"md","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"variant":"+autolink_bare_uris+emoji+footnotes+gfm_auto_identifiers+pipe_tables+strikeout+task_lists+tex_math_dollars"},"pandoc":{"standalone":true,"default-image-extension":"png","to":"commonmark","output-file":"django_q.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"comments":{"utterances":{"repo":"quarto-dev/quarto-web"}},"description":"Django-Q is a task queue and scheduler designed for Django, allowing you to run tasks asynchronously in the background, schedule recurring tasks, and handle distributed task queues. It’s an alternative to tools like Celery, providing a simpler, more Pythonic interface for handling asynchronous tasks in Django projects.","skip_exec":true,"skip_showdoc":true,"title":"django_q"}}},"projectFormats":["html","gfm"]}